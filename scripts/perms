#!/usr/bin/env ruby

require 'optparse'

options = {}

# Setting up available options

opts = OptionParser.new
opts.banner = "#{opts.banner} [<target>]"
opts.separator ''
opts.separator <<SEP
Perms prints or sets the permitions of files and directores. If used 
without any option or target the permitions of the visible items in
the current directory are displayed.

If a <target> is provided and it is a file, its permitions will be
displayed, if it is a directory the permitions of its contents will be
displayed.

If <target> is a folder the option --self can be used to display the
permitions of the folder itself, instead of their contents. Option
--contents can be used along with --self to display both the <target>
folder and its contents.

Options --files and -dirs can limit the displayed items to only files
or directories. By default both are shown. Using option --all displays
also hidden files and/or folders.

Using option --set_files or --set-dirs will modify the permitions of
any files and/or directories that are also displayed. Option --set-both
will modify the permitions of all items displayed.
SEP
opts.separator ''
opts.separator 'Options:'

opts.on('-f', '--files', 'Displays only files.') do
	options[:use_files] = true
end

opts.on('-d', '--dirs', 'Displays only directories.') do
	options[:use_dirs] = true
end

opts.on('-a', '--all', 'Also displays hidden files and/or directories.') do
	options[:use_all] = true
end

opts.on('-F', '--set-files MODE', OptionParser::OctalInteger, 'Sets MODE in all displayed files.') do |mode|
	options[:mode_files] = mode
end

opts.on('-D', '--set-dirs MODE', 'Sets MODE in all displayed directories.') do |mode|
	options[:mode_dirs] = mode
end

opts.on('-B', '--set-both MODE', 'Sets MODE in all displayed files and directories.') do |mode|
	options[:mode_files] = mode
	options[:mode_dirs] = mode
end

opts.on('-s', '--self', 'If the target is a directory, also displays and handles it.') do
	options[:use_self] = true
end

opts.on('-c', '--contents', 'If the --self option is used..') do
	options[:use_contents] = true
end

opts.on('-r', '--recursive', 'Enters recursively into subdirectories.') do
	options[:recursive] = true;
end

opts.on('-g', '--color', 'Displays colored output.') do
	options[:colorize] = true
end

opts.on('-v', '--verbose', 'When setting modes, see all unchanged entries.') do
	options[:verbose] = true
end

opts.separator ''

opts.on_tail('-h', '--help', 'Displays this help message and exits.') do
	options[:help] = true
end


# Parsing and handling help

begin
	opts.parse!
rescue OptionParser::ParseError
	warn $!.message
	warn 'use --help for more information'
	exit 1
end

if options[:help]
	puts opts.help
	exit
end

# No target means to use current directory
ARGV << '.' if ARGV.empty?

# No files or dirs options means both
if not options[:use_files] and not options[:use_dirs]
	options[:use_files] = true
	options[:use_dirs] = true
end

# Hash for errors encountered
errors = {}

# Array of all entries that will be handled
entries = []

# Each target passed is added to the entries
ARGV.each do |target|
	if not File.exists? target
		warn "'#{target}' no such file or directory"
		errors[:missing_target] = true
		next
	end
	
	# Do we have a file?
	if File.file? target and options[:use_files]
		entries << target
		next
	end
	
	# Not a file, we have a directory
	# For directories we keep a list of the directories we have to go
	# through, starting with the target itself
	dirs_to_check = ['.']
	
	# If using recursive we add to the list all subdirectories
	if options[:recursive]
		glob_params = ['**/']
		glob_params << File::FNM_DOTMATCH if options[:use_all]
		Dir.chdir(target) do |path|
			dirs_to_check += Dir.glob(*glob_params)
		end
	end
	
	# If self is used, the directory is an entry itself
	if options[:use_self]
		entries << target

		# We only continue with the directory contents if
		# we use recursive or contents
		if not options[:use_contents] and not options[:recursive]
			next
		end
	end
	
	glob_params = ['*']
	glob_params << File::FNM_DOTMATCH if options[:use_all]
	dirs_to_check.each do |subdir_target|
		# Clean up the path to check
		dir_parts = [target, subdir_target]
		dir_path = File.join(*dir_parts)
		
		# For each dir we keep the contents as entries
		Dir.chdir(dir_path) do |path|
			dir_contents = Dir.glob(*glob_params)
			dir_contents.delete('.')
			dir_contents.delete('..')
			
			# Cleanup of files or dirs, depending on options
			dir_contents.select! do |item|
				next true if options[:use_files] and File.file? item
				next true if options[:use_dirs] and File.directory? item
				false
			end
			
			# Add the leading path to properly add them as entries
			dir_parts.delete('.')
			dir_contents.map! do |value|
				File.join(*dir_parts, value)
			end
			
			entries += dir_contents
		end
	end

end # each

entries.each do |entry|
	stats = File.stat(entry)
	perms = sprintf('%o', stats.mode)
	perms = perms[-3, 3]
	
	puts "#{perms} #{entry}"
end

exit 0


